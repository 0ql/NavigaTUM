/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * NavigaTUM
 * Navigating around TUM with excellence â€“ An API to search for rooms, buildings and other places  NavigaTUM is a non-official tool developed by students for students, that aims to help you get around at [TUM](https://tum.de). Feel free to contribute.  Features:  - Interactive or RoomFinder-like maps to lookup the position of rooms or buildings - Fast and typo-tolerant search - Support for different room code formats as well as generic names  All functionality is also available via an API.  *Note: Not all buildings in NavigaTUM are owned by TUM, but are instead being used by TUM departments.*
 *
 * OpenAPI spec version: 1.0.0
 * Contact: app@tum.de
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://nav.tum.sexy".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = isomorphicFetch
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: "RequiredError";
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface BaseDetailsResponse
 */
export interface BaseDetailsResponse {
  /**
   * The type of the entry in a human-readable form
   * @type {string}
   * @memberof BaseDetailsResponse
   */
  typeCommonName: string;
  /**
   * The name of the entry in a human-readable form
   * @type {string}
   * @memberof BaseDetailsResponse
   */
  name: string;
  /**
   *
   * @type {Array<string>}
   * @memberof BaseDetailsResponse
   */
  parents: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof BaseDetailsResponse
   */
  parentNames: Array<string>;
  /**
   *
   * @type {Props}
   * @memberof BaseDetailsResponse
   */
  props: Props;
  /**
   *
   * @type {Array<ImageInfo>}
   * @memberof BaseDetailsResponse
   */
  imgs?: Array<ImageInfo>;
  /**
   *
   * @type {RankingFactors}
   * @memberof BaseDetailsResponse
   */
  rankingFactors: RankingFactors;
}
/**
 * A comment to show to an entry. It is used in the rare cases, where some aspect about the rooom/ translation are misleading.
 * @export
 * @interface CommentProp
 */
export interface CommentProp {
  /**
   * German version of the comment
   * @type {string}
   * @memberof CommentProp
   */
  de?: string;
  /**
   * English version of the comment
   * @type {string}
   * @memberof CommentProp
   */
  en?: string;
}
/**
 *
 * @export
 * @interface ComputedProp
 */
export interface ComputedProp {
  /**
   *
   * @type {string}
   * @memberof ComputedProp
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ComputedProp
   */
  text: string;
}
/**
 *
 * @export
 * @interface Coordinate
 */
export interface Coordinate {
  /**
   * The latitude
   * @type {number}
   * @memberof Coordinate
   */
  lat: number;
  /**
   * The latitude
   * @type {number}
   * @memberof Coordinate
   */
  lon: number;
  /**
   * The source of the Coordinates
   * @type {string}
   * @memberof Coordinate
   */
  source: string;
  /**
   *
   * @type {CoordinateUtm}
   * @memberof Coordinate
   */
  utm?: CoordinateUtm;
}
/**
 *
 * @export
 * @interface CoordinateUtm
 */
export interface CoordinateUtm {
  /**
   * The easting
   * @type {number}
   * @memberof CoordinateUtm
   */
  easting?: number;
  /**
   * The northing
   * @type {number}
   * @memberof CoordinateUtm
   */
  northing?: number;
  /**
   * The zone
   * @type {string}
   * @memberof CoordinateUtm
   */
  zone?: string;
  /**
   * The zone number
   * @type {number}
   * @memberof CoordinateUtm
   */
  zoneNumber?: number;
}
/**
 *
 * @export
 * @interface DetailsResponse
 */
export interface DetailsResponse extends BaseDetailsResponse {
  /**
   * The id, that was requested
   * @type {string}
   * @memberof DetailsResponse
   */
  id: string;
  /**
   * The type of the entry
   * @type {string}
   * @memberof DetailsResponse
   */
  type: DetailsResponse.TypeEnum;
  /**
   *
   * @type {Coordinate}
   * @memberof DetailsResponse
   */
  coords: Coordinate;
  /**
   *
   * @type {Maps}
   * @memberof DetailsResponse
   */
  maps: Maps;
}

/**
 * @export
 * @namespace DetailsResponse
 */
export namespace DetailsResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    Room = <any>"room",
    Building = <any>"building",
    JoinedBuilding = <any>"joined_building",
    Area = <any>"area",
    Site = <any>"site",
    Campus = <any>"campus",
  }
}
/**
 * The information you need to request Images from the /cdn/{size}/{id}_{counter}.webp endpoint
 * @export
 * @interface ImageInfo
 */
export interface ImageInfo {
  /**
   * The name of the image file. consists of {building_id}_{image_id}.webp, where image_id is a counter starting at 0
   * @type {string}
   * @memberof ImageInfo
   */
  name: string;
  /**
   *
   * @type {PossibleURLRef}
   * @memberof ImageInfo
   */
  author: PossibleURLRef;
  /**
   *
   * @type {PossibleURLRef}
   * @memberof ImageInfo
   */
  source: PossibleURLRef;
  /**
   *
   * @type {PossibleURLRef}
   * @memberof ImageInfo
   */
  license: PossibleURLRef;
  /**
   *
   * @type {ImageMetadata}
   * @memberof ImageInfo
   */
  meta?: ImageMetadata;
  /**
   *
   * @type {SitesBuildings | Rooms}
   * @memberof ImageInfo
   */
  sections?: SitesBuildings | Rooms;
}
/**
 * Aditional data about the images. Does not have to be displayed. All fields are optional.
 * @export
 * @interface ImageMetadata
 */
export interface ImageMetadata {
  /**
   * optional date description
   * @type {string}
   * @memberof ImageMetadata
   */
  date?: string;
  /**
   * optional location description
   * @type {string}
   * @memberof ImageMetadata
   */
  location?: string;
  /**
   * optional coordinates in lat,lon
   * @type {string}
   * @memberof ImageMetadata
   */
  geo?: string;
  /**
   * optional in contrast to source this points to the image itself. You should not use this to request the images, as they are not scaled.
   * @type {string}
   * @memberof ImageMetadata
   */
  imageUrl?: string;
  /**
   * optional caption
   * @type {string}
   * @memberof ImageMetadata
   */
  caption?: string;
  /**
   * optional headline
   * @type {string}
   * @memberof ImageMetadata
   */
  headline?: string;
  /**
   * optional the event this image was taken at
   * @type {string}
   * @memberof ImageMetadata
   */
  event?: string;
  /**
   * optional the event this image is about
   * @type {string}
   * @memberof ImageMetadata
   */
  faculty?: string;
  /**
   * optional the building this image is about
   * @type {string}
   * @memberof ImageMetadata
   */
  building?: string;
  /**
   * optional the department this image is about
   * @type {string}
   * @memberof ImageMetadata
   */
  department?: string;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {}
/**
 * A link with a localized link text and url
 * @export
 * @interface LinkProp
 */
export interface LinkProp {
  /**
   *
   * @type {LinkPropText}
   * @memberof LinkProp
   */
  text: LinkPropText;
  /**
   *
   * @type {LinkPropText}
   * @memberof LinkProp
   */
  url: LinkPropText;
}
/**
 *
 * @export
 * @interface LinkPropText
 */
export interface LinkPropText {
  /**
   *
   * @type {string}
   * @memberof LinkPropText
   */
  de: string;
  /**
   *
   * @type {string}
   * @memberof LinkPropText
   */
  en: string;
}
/**
 *
 * @export
 * @interface Maps
 */
export interface Maps {
  /**
   * The type of the Map that should be shown by default
   * @type {string}
   * @memberof Maps
   */
  _default: Maps.DefaultEnum;
  /**
   *
   * @type {RoomfinderMap}
   * @memberof Maps
   */
  roomfinder?: RoomfinderMap;
  /**
   * null would mean no overlay maps are displayed by default. For rooms you should add a warning that no floor map is available for this room
   * @type {any & OverlayMap}
   * @memberof Maps
   */
  overlays?: any & OverlayMap;
}

/**
 * @export
 * @namespace Maps
 */
export namespace Maps {
  /**
   * @export
   * @enum {string}
   */
  export enum DefaultEnum {
    Interactive = <any>"interactive",
    Roomfinder = <any>"roomfinder",
  }
}
/**
 *
 * @export
 * @interface OverlayMap
 */
export interface OverlayMap {
  /**
   * The floor-id of the map, that should be shown as a default.   null: - We suggest, you dont show a map by default. - This is only the case for buildings or other such entities and not for rooms, if we know where they are and a map exists
   * @type {number}
   * @memberof OverlayMap
   */
  _default: number;
  /**
   *
   * @type {Array<OverlayMapEntry>}
   * @memberof OverlayMap
   */
  available: Array<OverlayMapEntry>;
}
/**
 *
 * @export
 * @interface OverlayMapEntry
 */
export interface OverlayMapEntry {
  /**
   * The machine-readable floor-id of the map.   Should start with 0 for the ground level (defined by the main entrance) and increase or decrease. It is not guaranteed that numbers are consecutive or that `1` corresponds to level `01`, because buildings sometimes have more complicated layouts. They are however always in the correct (physical) order.
   * @type {number}
   * @memberof OverlayMapEntry
   */
  id: number;
  /**
   * Floor of the Map. Should be used for display to the user in selectors.   Matches the floor part of the TUMonline roomcode.
   * @type {string}
   * @memberof OverlayMapEntry
   */
  floor: string;
  /**
   * The human-readable name of the map
   * @type {string}
   * @memberof OverlayMapEntry
   */
  name: string;
  /**
   * The filename of the map
   * @type {string}
   * @memberof OverlayMapEntry
   */
  file: string;
  /**
   * Coordinates are four [lon, lat] pairs, for the top left, top right, bottom right, bottom left image corners.
   * @type {Array<Array<number>>}
   * @memberof OverlayMapEntry
   */
  coordinates: Array<Array<number>>;
}
/**
 * Additional information you should include, if you decide to display the image for legal and attribution reasons
 * @export
 * @interface PossibleURLRef
 */
export interface PossibleURLRef {
  /**
   * The text to display
   * @type {string}
   * @memberof PossibleURLRef
   */
  text: string;
  /**
   * The URL to the referenced information. Always either null or a valid URL
   * @type {string}
   * @memberof PossibleURLRef
   */
  url?: string;
}
/**
 * Data for the info-card table
 * @export
 * @interface Props
 */
export interface Props {
  /**
   *
   * @type {Array<ComputedProp>}
   * @memberof Props
   */
  computed: Array<ComputedProp>;
  /**
   *
   * @type {Array<LinkProp>}
   * @memberof Props
   */
  links?: Array<LinkProp>;
}
/**
 *
 * @export
 * @interface RankingFactors
 */
export interface RankingFactors {
  /**
   * How much the combined ranking is important
   * @type {number}
   * @memberof RankingFactors
   */
  rankCombined: number;
  /**
   * How much the type is important
   * @type {number}
   * @memberof RankingFactors
   */
  rankType: number;
  /**
   * How much the usage is important
   * @type {number}
   * @memberof RankingFactors
   */
  rankUsage: number;
  /**
   * Automatic boost or suppression based on entry properties: - numbers of buildings for a `campus`/`area`/`site`, - numbers of seats for a `room`, - number of regular rooms for a `building`/`joined_building`
   * @type {number}
   * @memberof RankingFactors
   */
  rankBoost?: number;
  /**
   * Custom boost or suppression factor defined by us
   * @type {number}
   * @memberof RankingFactors
   */
  rankCustom?: number;
}
/**
 *
 * @export
 * @interface RoomEntry
 */
export interface RoomEntry extends SitesBuildingsEntry {
  /**
   * Subtext to show below the search (by default in bold and after the non-bold subtext). Usually contains the arch-id of the room, which is another common room id format, and supports highlighting.
   * @type {string}
   * @memberof RoomEntry
   */
  subtextBold: string;
  /**
   * This is an optional feature, that is only supported for some rooms. It might be displayed instead or before the name, to show that a different room id format has matched, that was probably used. See the image below for an example. It will be cropped to a maximum length to not take too much space in UIs. Supports highlighting.
   * @type {string}
   * @memberof RoomEntry
   */
  parsedId?: string;
}
/**
 *
 * @export
 * @interface RoomfinderMap
 */
export interface RoomfinderMap {
  /**
   * The id of the map, that should be shown as a default
   * @type {string}
   * @memberof RoomfinderMap
   */
  _default: string;
  /**
   *
   * @type {Array<RoomfinderMapEntry>}
   * @memberof RoomfinderMap
   */
  available: Array<RoomfinderMapEntry>;
}
/**
 *
 * @export
 * @interface RoomfinderMapEntry
 */
export interface RoomfinderMapEntry {
  /**
   * The human-readable name of the map
   * @type {string}
   * @memberof RoomfinderMapEntry
   */
  name: string;
  /**
   * The machine-readable name of the map
   * @type {string}
   * @memberof RoomfinderMapEntry
   */
  id: string;
  /**
   * Scale of the map. 2000 means 1:2000.
   * @type {string}
   * @memberof RoomfinderMapEntry
   */
  scale: string;
  /**
   * Map image x dimensions
   * @type {number}
   * @memberof RoomfinderMapEntry
   */
  height: number;
  /**
   * Map image y dimensions
   * @type {number}
   * @memberof RoomfinderMapEntry
   */
  width: number;
  /**
   * x Position on map
   * @type {number}
   * @memberof RoomfinderMapEntry
   */
  x: number;
  /**
   * y Position on map image
   * @type {number}
   * @memberof RoomfinderMapEntry
   */
  y: number;
}
/**
 *
 * @export
 * @interface Rooms
 */
export interface Rooms {
  /**
   * These indicate the type of item this represents
   * @type {string}
   * @memberof Rooms
   */
  facet: Rooms.FacetEnum;
  /**
   * The estimated (not exact) number of hits for that query
   * @type {number}
   * @memberof Rooms
   */
  estimatedTotalHits: number;
  /**
   *
   * @type {Array<RoomEntry>}
   * @memberof Rooms
   */
  entries: Array<RoomEntry>;
}

/**
 * @export
 * @namespace Rooms
 */
export namespace Rooms {
  /**
   * @export
   * @enum {string}
   */
  export enum FacetEnum {
    Rooms = <any>"rooms",
  }
}
/**
 *
 * @export
 * @interface RootResponse
 */
export interface RootResponse extends BaseDetailsResponse {
  /**
   * The id, that was requested
   * @type {string}
   * @memberof RootResponse
   */
  id: RootResponse.IdEnum;
  /**
   * The type of the entry
   * @type {string}
   * @memberof RootResponse
   */
  type: RootResponse.TypeEnum;
}

/**
 * @export
 * @namespace RootResponse
 */
export namespace RootResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum IdEnum {
    Root = <any>"root",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    Root = <any>"root",
  }
}
/**
 *
 * @export
 * @interface SearchResponse
 */
export interface SearchResponse {
  /**
   *
   * @type {Array<SitesBuildings | Rooms>}
   * @memberof SearchResponse
   */
  sections: Array<SitesBuildings | Rooms>;
  /**
   * Time the search took in the server side, not including network delay Maximum as by awc timeout. other timeouts (browser, your client) may be smaller Expected average is 10..50 for uncached, regular requests
   * @type {number}
   * @memberof SearchResponse
   */
  timeMs: number;
}
/**
 *
 * @export
 * @interface SitesBuildings
 */
export interface SitesBuildings {
  /**
   * These indicate the type of item this represents
   * @type {string}
   * @memberof SitesBuildings
   */
  facet: SitesBuildings.FacetEnum;
  /**
   * The estimated (not exact) number of hits for that query
   * @type {number}
   * @memberof SitesBuildings
   */
  estimatedTotalHits: number;
  /**
   *
   * @type {Array<SitesBuildingsEntry>}
   * @memberof SitesBuildings
   */
  entries: Array<SitesBuildingsEntry>;
  /**
   * A recommendation how many of the entries should be displayed by default.   The number is usually from 0-5.   More results might be displayed when clicking \"expand\".   If this field is not present, then all entries are displayed.
   * @type {number}
   * @memberof SitesBuildings
   */
  nVisible?: number;
}

/**
 * @export
 * @namespace SitesBuildings
 */
export namespace SitesBuildings {
  /**
   * @export
   * @enum {string}
   */
  export enum FacetEnum {
    SitesBuildings = <any>"sites_buildings",
  }
}
/**
 *
 * @export
 * @interface SitesBuildingsEntry
 */
export interface SitesBuildingsEntry {
  /**
   * The id of the room
   * @type {string}
   * @memberof SitesBuildingsEntry
   */
  id: string;
  /**
   * the type of the room/site/building
   * @type {string}
   * @memberof SitesBuildingsEntry
   */
  type: string;
  /**
   * Subtext to show below the search result. Usually contains the context of where this rooms is located in. Currently not highlighted.
   * @type {string}
   * @memberof SitesBuildingsEntry
   */
  name: string;
  /**
   * Subtext to show below the search result. Usually contains the context of where this rooms is located in. Currently not highlighted.
   * @type {string}
   * @memberof SitesBuildingsEntry
   */
  subtext: string;
}
/**
 *
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
  /**
   * The token, that can be used to generate feedback
   * @type {string}
   * @memberof TokenRequest
   */
  token: string;
  /**
   * The category of the feedback.   Enum attribute is softly enforced: Any value not listed below will be replaced by \"other\"
   * @type {string}
   * @memberof TokenRequest
   */
  category: TokenRequest.CategoryEnum;
  /**
   * The subject/title of the feedback
   * @type {string}
   * @memberof TokenRequest
   */
  subject: string;
  /**
   * The body/description of the feedback
   * @type {string}
   * @memberof TokenRequest
   */
  body: string;
  /**
   * Whether the user has checked the privacy-checkbox. We are posting the feedback publicly on GitHub (not a EU-Company). You have to also include such a checkmark. For inspiration on how to do this, see our website.
   * @type {boolean}
   * @memberof TokenRequest
   */
  privacyChecked: boolean;
  /**
   * Whether the user has requested to delete the issue. If the user has requested to delete the issue, we will delete it from GitHub after processing it If the user has not requested to delete the issue, we will not delete it from GitHub and it will remain as a closed issue.
   * @type {boolean}
   * @memberof TokenRequest
   */
  deleteIssueRequested: boolean;
}

/**
 * @export
 * @namespace TokenRequest
 */
export namespace TokenRequest {
  /**
   * @export
   * @enum {string}
   */
  export enum CategoryEnum {
    General = <any>"general",
    Bug = <any>"bug",
    Feature = <any>"feature",
    Search = <any>"search",
    Entry = <any>"entry",
    Other = <any>"other",
  }
}
/**
 *
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
  /**
   * The token, that can be used to generate feedback
   * @type {string}
   * @memberof TokenResponse
   */
  token: string;
}
/**
 * CdnApi - fetch parameter creator
 * @export
 */
export const CdnApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * This endpoint is designed to fetch the images, that are described by the `/api/get/{id}`-endpoint. You HAVE to get the proper attribution from that endpoint and use it.
     * @summary Get title images
     * @param {string} size size of the resource you want  | name   | default                                                               | |--------|-----------------------------------------------------------------------| | lg     | max 4k, aspect ratio untouched                                        | | md     | max 1920px, aspect ratio untouched                                    | | sm     | max 1024px, aspect ratio untouched                                    | | thumb  | 256x256, cropped to fit. Usually a center-crop, but sometimes offset. | | header | 512x210, cropped to fit. Usually a center-crop, but sometimes offset. |
     * @param {string} id id of the recource you want an image for
     * @param {number} counter counter of the image you want.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imgCdn(
      size: string,
      id: string,
      counter: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'size' is not null or undefined
      if (size === null || size === undefined) {
        throw new RequiredError(
          "size",
          "Required parameter size was null or undefined when calling imgCdn."
        );
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling imgCdn."
        );
      }
      // verify required parameter 'counter' is not null or undefined
      if (counter === null || counter === undefined) {
        throw new RequiredError(
          "counter",
          "Required parameter counter was null or undefined when calling imgCdn."
        );
      }
      const localVarPath = `/cdn/{size}/{id}_{counter}.webp`
        .replace(`{${"size"}}`, encodeURIComponent(String(size)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"counter"}}`, encodeURIComponent(String(counter)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint is designed to fetch the images, that are described by the `/api/get/{id}`-endpoint. You HAVE to get the proper attribution from that endpoint and use it.
     * @summary Get title images
     * @param {string} source source of the resource you want
     * @param {string} id id of the map you want
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mapsCdn(source: string, id: string, options: any = {}): FetchArgs {
      // verify required parameter 'source' is not null or undefined
      if (source === null || source === undefined) {
        throw new RequiredError(
          "source",
          "Required parameter source was null or undefined when calling mapsCdn."
        );
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling mapsCdn."
        );
      }
      const localVarPath = `/cdn/maps/{source}/{id}.webp`
        .replace(`{${"source"}}`, encodeURIComponent(String(source)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CdnApi - functional programming interface
 * @export
 */
export const CdnApiFp = function (configuration?: Configuration) {
  return {
    /**
     * This endpoint is designed to fetch the images, that are described by the `/api/get/{id}`-endpoint. You HAVE to get the proper attribution from that endpoint and use it.
     * @summary Get title images
     * @param {string} size size of the resource you want  | name   | default                                                               | |--------|-----------------------------------------------------------------------| | lg     | max 4k, aspect ratio untouched                                        | | md     | max 1920px, aspect ratio untouched                                    | | sm     | max 1024px, aspect ratio untouched                                    | | thumb  | 256x256, cropped to fit. Usually a center-crop, but sometimes offset. | | header | 512x210, cropped to fit. Usually a center-crop, but sometimes offset. |
     * @param {string} id id of the recource you want an image for
     * @param {number} counter counter of the image you want.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imgCdn(
      size: string,
      id: string,
      counter: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
      const localVarFetchArgs = CdnApiFetchParamCreator(configuration).imgCdn(
        size,
        id,
        counter,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * This endpoint is designed to fetch the images, that are described by the `/api/get/{id}`-endpoint. You HAVE to get the proper attribution from that endpoint and use it.
     * @summary Get title images
     * @param {string} source source of the resource you want
     * @param {string} id id of the map you want
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mapsCdn(
      source: string,
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
      const localVarFetchArgs = CdnApiFetchParamCreator(configuration).mapsCdn(
        source,
        id,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * CdnApi - factory interface
 * @export
 */
export const CdnApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * This endpoint is designed to fetch the images, that are described by the `/api/get/{id}`-endpoint. You HAVE to get the proper attribution from that endpoint and use it.
     * @summary Get title images
     * @param {string} size size of the resource you want  | name   | default                                                               | |--------|-----------------------------------------------------------------------| | lg     | max 4k, aspect ratio untouched                                        | | md     | max 1920px, aspect ratio untouched                                    | | sm     | max 1024px, aspect ratio untouched                                    | | thumb  | 256x256, cropped to fit. Usually a center-crop, but sometimes offset. | | header | 512x210, cropped to fit. Usually a center-crop, but sometimes offset. |
     * @param {string} id id of the recource you want an image for
     * @param {number} counter counter of the image you want.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imgCdn(size: string, id: string, counter: number, options?: any) {
      return CdnApiFp(configuration).imgCdn(
        size,
        id,
        counter,
        options
      )(fetch, basePath);
    },
    /**
     * This endpoint is designed to fetch the images, that are described by the `/api/get/{id}`-endpoint. You HAVE to get the proper attribution from that endpoint and use it.
     * @summary Get title images
     * @param {string} source source of the resource you want
     * @param {string} id id of the map you want
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mapsCdn(source: string, id: string, options?: any) {
      return CdnApiFp(configuration).mapsCdn(
        source,
        id,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * CdnApi - object-oriented interface
 * @export
 * @class CdnApi
 * @extends {BaseAPI}
 */
export class CdnApi extends BaseAPI {
  /**
   * This endpoint is designed to fetch the images, that are described by the `/api/get/{id}`-endpoint. You HAVE to get the proper attribution from that endpoint and use it.
   * @summary Get title images
   * @param {string} size size of the resource you want  | name   | default                                                               | |--------|-----------------------------------------------------------------------| | lg     | max 4k, aspect ratio untouched                                        | | md     | max 1920px, aspect ratio untouched                                    | | sm     | max 1024px, aspect ratio untouched                                    | | thumb  | 256x256, cropped to fit. Usually a center-crop, but sometimes offset. | | header | 512x210, cropped to fit. Usually a center-crop, but sometimes offset. |
   * @param {string} id id of the recource you want an image for
   * @param {number} counter counter of the image you want.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CdnApi
   */
  public imgCdn(size: string, id: string, counter: number, options?: any) {
    return CdnApiFp(this.configuration).imgCdn(
      size,
      id,
      counter,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * This endpoint is designed to fetch the images, that are described by the `/api/get/{id}`-endpoint. You HAVE to get the proper attribution from that endpoint and use it.
   * @summary Get title images
   * @param {string} source source of the resource you want
   * @param {string} id id of the map you want
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CdnApi
   */
  public mapsCdn(source: string, id: string, options?: any) {
    return CdnApiFp(this.configuration).mapsCdn(
      source,
      id,
      options
    )(this.fetch, this.basePath);
  }
}
/**
 * CoreApi - fetch parameter creator
 * @export
 */
export const CoreApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * This returns the full data available for the entry (room/building).  This is more data, that should be supplied once a user clicks on an entry. Preloading this is not an issue on our end, but keep in mind bandwith constraints on your side. The data can be up to 50kB (using gzip) or 200kB unzipped The exact data format is specified in the NavigaTUM-data documentation
     * @summary Get entry-details
     * @param {string} id string you want to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    details(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling details."
        );
      }
      const localVarPath = `/api/get/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint is designed to support search-as-you-type results.  Instead of simply returning a list, the search results are returned in a way to provide a richer experience by splitting them up into sections. You might not necessarily need to implement all types of sections, or all sections features (if you just want to show a list). The order of sections is a suggested order to display them, but you may change this as you like.  Some fields support highlighting the query terms and it uses \\x19 and \\x17 to mark the beginning/end of a highlighted sequence.   (See [Wikipedia](https://en.wikipedia.org/wiki/C0_and_C1_control_codes#Modified_C0_control_code_sets)).   Some text-renderers will ignore them, but in case you do not want to use them, you might want to remove them from the responses via empty `pre_highlight` and `pre_highlight` query parameters.
     * @summary Search entries
     * @param {string} q string you want to search for. Note, that the amounts returned can be controlled using the limit\\* paramerters.
     * @param {number} [limitBuildings] Maximum number of buildings/sites to return.   Clamped to 0..1000. If this is an problem for you, please open an issue.
     * @param {number} [limitRooms] Maximum number of rooms to return.   Clamped to 0..1000. If this is an problem for you, please open an issue.
     * @param {number} [limitAll] Overall maximum number of results. Only visible results are counted (i.e. hidden buildings are not counted).   Clamped to 1..1000. If this is an problem for you, please open an issue.
     * @param {string} [preHighlight] string to include in front of highlighted sequences.    If this and &#x60;post_highlight&#x60; are empty, highlighting is disabled.
     * @param {string} [postHighlight] string to include after the highlighted sequences.    If this and &#x60;pre_highlight&#x60; are empty, highlighting is disabled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    search(
      q: string,
      limitBuildings?: number,
      limitRooms?: number,
      limitAll?: number,
      preHighlight?: string,
      postHighlight?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'q' is not null or undefined
      if (q === null || q === undefined) {
        throw new RequiredError(
          "q",
          "Required parameter q was null or undefined when calling search."
        );
      }
      const localVarPath = `/api/search`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter["q"] = q;
      }

      if (limitBuildings !== undefined) {
        localVarQueryParameter["limit_buildings"] = limitBuildings;
      }

      if (limitRooms !== undefined) {
        localVarQueryParameter["limit_rooms"] = limitRooms;
      }

      if (limitAll !== undefined) {
        localVarQueryParameter["limit_all"] = limitAll;
      }

      if (preHighlight !== undefined) {
        localVarQueryParameter["pre_highlight"] = preHighlight;
      }

      if (postHighlight !== undefined) {
        localVarQueryParameter["post_highlight"] = postHighlight;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint returns a link to the source-code of the repository at the currently running version. This endpoint is not required for modifications (as the license is not AGPL), but strongly encouraged.
     * @summary Get link to running source-code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sourceCode(options: any = {}): FetchArgs {
      const localVarPath = `/api/source_code`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CoreApi - functional programming interface
 * @export
 */
export const CoreApiFp = function (configuration?: Configuration) {
  return {
    /**
     * This returns the full data available for the entry (room/building).  This is more data, that should be supplied once a user clicks on an entry. Preloading this is not an issue on our end, but keep in mind bandwith constraints on your side. The data can be up to 50kB (using gzip) or 200kB unzipped The exact data format is specified in the NavigaTUM-data documentation
     * @summary Get entry-details
     * @param {string} id string you want to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    details(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
      const localVarFetchArgs = CoreApiFetchParamCreator(configuration).details(
        id,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * This endpoint is designed to support search-as-you-type results.  Instead of simply returning a list, the search results are returned in a way to provide a richer experience by splitting them up into sections. You might not necessarily need to implement all types of sections, or all sections features (if you just want to show a list). The order of sections is a suggested order to display them, but you may change this as you like.  Some fields support highlighting the query terms and it uses \\x19 and \\x17 to mark the beginning/end of a highlighted sequence.   (See [Wikipedia](https://en.wikipedia.org/wiki/C0_and_C1_control_codes#Modified_C0_control_code_sets)).   Some text-renderers will ignore them, but in case you do not want to use them, you might want to remove them from the responses via empty `pre_highlight` and `pre_highlight` query parameters.
     * @summary Search entries
     * @param {string} q string you want to search for. Note, that the amounts returned can be controlled using the limit\\* paramerters.
     * @param {number} [limitBuildings] Maximum number of buildings/sites to return.   Clamped to 0..1000. If this is an problem for you, please open an issue.
     * @param {number} [limitRooms] Maximum number of rooms to return.   Clamped to 0..1000. If this is an problem for you, please open an issue.
     * @param {number} [limitAll] Overall maximum number of results. Only visible results are counted (i.e. hidden buildings are not counted).   Clamped to 1..1000. If this is an problem for you, please open an issue.
     * @param {string} [preHighlight] string to include in front of highlighted sequences.    If this and &#x60;post_highlight&#x60; are empty, highlighting is disabled.
     * @param {string} [postHighlight] string to include after the highlighted sequences.    If this and &#x60;pre_highlight&#x60; are empty, highlighting is disabled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    search(
      q: string,
      limitBuildings?: number,
      limitRooms?: number,
      limitAll?: number,
      preHighlight?: string,
      postHighlight?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<SearchResponse> {
      const localVarFetchArgs = CoreApiFetchParamCreator(configuration).search(
        q,
        limitBuildings,
        limitRooms,
        limitAll,
        preHighlight,
        postHighlight,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * This endpoint returns a link to the source-code of the repository at the currently running version. This endpoint is not required for modifications (as the license is not AGPL), but strongly encouraged.
     * @summary Get link to running source-code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sourceCode(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs =
        CoreApiFetchParamCreator(configuration).sourceCode(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * CoreApi - factory interface
 * @export
 */
export const CoreApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * This returns the full data available for the entry (room/building).  This is more data, that should be supplied once a user clicks on an entry. Preloading this is not an issue on our end, but keep in mind bandwith constraints on your side. The data can be up to 50kB (using gzip) or 200kB unzipped The exact data format is specified in the NavigaTUM-data documentation
     * @summary Get entry-details
     * @param {string} id string you want to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    details(id: string, options?: any) {
      return CoreApiFp(configuration).details(id, options)(fetch, basePath);
    },
    /**
     * This endpoint is designed to support search-as-you-type results.  Instead of simply returning a list, the search results are returned in a way to provide a richer experience by splitting them up into sections. You might not necessarily need to implement all types of sections, or all sections features (if you just want to show a list). The order of sections is a suggested order to display them, but you may change this as you like.  Some fields support highlighting the query terms and it uses \\x19 and \\x17 to mark the beginning/end of a highlighted sequence.   (See [Wikipedia](https://en.wikipedia.org/wiki/C0_and_C1_control_codes#Modified_C0_control_code_sets)).   Some text-renderers will ignore them, but in case you do not want to use them, you might want to remove them from the responses via empty `pre_highlight` and `pre_highlight` query parameters.
     * @summary Search entries
     * @param {string} q string you want to search for. Note, that the amounts returned can be controlled using the limit\\* paramerters.
     * @param {number} [limitBuildings] Maximum number of buildings/sites to return.   Clamped to 0..1000. If this is an problem for you, please open an issue.
     * @param {number} [limitRooms] Maximum number of rooms to return.   Clamped to 0..1000. If this is an problem for you, please open an issue.
     * @param {number} [limitAll] Overall maximum number of results. Only visible results are counted (i.e. hidden buildings are not counted).   Clamped to 1..1000. If this is an problem for you, please open an issue.
     * @param {string} [preHighlight] string to include in front of highlighted sequences.    If this and &#x60;post_highlight&#x60; are empty, highlighting is disabled.
     * @param {string} [postHighlight] string to include after the highlighted sequences.    If this and &#x60;pre_highlight&#x60; are empty, highlighting is disabled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    search(
      q: string,
      limitBuildings?: number,
      limitRooms?: number,
      limitAll?: number,
      preHighlight?: string,
      postHighlight?: string,
      options?: any
    ) {
      return CoreApiFp(configuration).search(
        q,
        limitBuildings,
        limitRooms,
        limitAll,
        preHighlight,
        postHighlight,
        options
      )(fetch, basePath);
    },
    /**
     * This endpoint returns a link to the source-code of the repository at the currently running version. This endpoint is not required for modifications (as the license is not AGPL), but strongly encouraged.
     * @summary Get link to running source-code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sourceCode(options?: any) {
      return CoreApiFp(configuration).sourceCode(options)(fetch, basePath);
    },
  };
};

/**
 * CoreApi - object-oriented interface
 * @export
 * @class CoreApi
 * @extends {BaseAPI}
 */
export class CoreApi extends BaseAPI {
  /**
   * This returns the full data available for the entry (room/building).  This is more data, that should be supplied once a user clicks on an entry. Preloading this is not an issue on our end, but keep in mind bandwith constraints on your side. The data can be up to 50kB (using gzip) or 200kB unzipped The exact data format is specified in the NavigaTUM-data documentation
   * @summary Get entry-details
   * @param {string} id string you want to search for
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreApi
   */
  public details(id: string, options?: any) {
    return CoreApiFp(this.configuration).details(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * This endpoint is designed to support search-as-you-type results.  Instead of simply returning a list, the search results are returned in a way to provide a richer experience by splitting them up into sections. You might not necessarily need to implement all types of sections, or all sections features (if you just want to show a list). The order of sections is a suggested order to display them, but you may change this as you like.  Some fields support highlighting the query terms and it uses \\x19 and \\x17 to mark the beginning/end of a highlighted sequence.   (See [Wikipedia](https://en.wikipedia.org/wiki/C0_and_C1_control_codes#Modified_C0_control_code_sets)).   Some text-renderers will ignore them, but in case you do not want to use them, you might want to remove them from the responses via empty `pre_highlight` and `pre_highlight` query parameters.
   * @summary Search entries
   * @param {string} q string you want to search for. Note, that the amounts returned can be controlled using the limit\\* paramerters.
   * @param {number} [limitBuildings] Maximum number of buildings/sites to return.   Clamped to 0..1000. If this is an problem for you, please open an issue.
   * @param {number} [limitRooms] Maximum number of rooms to return.   Clamped to 0..1000. If this is an problem for you, please open an issue.
   * @param {number} [limitAll] Overall maximum number of results. Only visible results are counted (i.e. hidden buildings are not counted).   Clamped to 1..1000. If this is an problem for you, please open an issue.
   * @param {string} [preHighlight] string to include in front of highlighted sequences.    If this and &#x60;post_highlight&#x60; are empty, highlighting is disabled.
   * @param {string} [postHighlight] string to include after the highlighted sequences.    If this and &#x60;pre_highlight&#x60; are empty, highlighting is disabled.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreApi
   */
  public search(
    q: string,
    limitBuildings?: number,
    limitRooms?: number,
    limitAll?: number,
    preHighlight?: string,
    postHighlight?: string,
    options?: any
  ) {
    return CoreApiFp(this.configuration).search(
      q,
      limitBuildings,
      limitRooms,
      limitAll,
      preHighlight,
      postHighlight,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * This endpoint returns a link to the source-code of the repository at the currently running version. This endpoint is not required for modifications (as the license is not AGPL), but strongly encouraged.
   * @summary Get link to running source-code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreApi
   */
  public sourceCode(options?: any) {
    return CoreApiFp(this.configuration).sourceCode(options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * FeedbackApi - fetch parameter creator
 * @export
 */
export const FeedbackApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * ***Do not abuse this endpoint.***  This posts the actual feedback to github and returns the github link. For this Endpoint to work, you need to generate a token via the `/api/feedback/get_token` endpoint.  ***Important Note:*** Tokens are only used if we return a 201 Created response. Otherwise, they are still valid
     * @summary Post feedback
     * @param {TokenRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedback(body?: TokenRequest, options: any = {}): FetchArgs {
      const localVarPath = `/api/feedback/feedback`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"TokenRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ***Do not abuse this endpoint.***  This returns a token usable for submitting feedback. You should request a token, ***if (and only if) a user is on a feedback page***  As a rudimentary way of rate-limiting feedback, this endpoint returns a token. To post feedback, you will need this token.  Tokens gain validity after 10s, and are invalid after 12h of being issued. They are not refreshable, and are only valid for one usage.  Global Rate-Limiting:  - hourly: 20 tokens per hour  - daily: 50 tokens per
     * @summary Get a feedback-token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getToken(options: any = {}): FetchArgs {
      const localVarPath = `/api/feedback/get_token`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FeedbackApi - functional programming interface
 * @export
 */
export const FeedbackApiFp = function (configuration?: Configuration) {
  return {
    /**
     * ***Do not abuse this endpoint.***  This posts the actual feedback to github and returns the github link. For this Endpoint to work, you need to generate a token via the `/api/feedback/get_token` endpoint.  ***Important Note:*** Tokens are only used if we return a 201 Created response. Otherwise, they are still valid
     * @summary Post feedback
     * @param {TokenRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedback(
      body?: TokenRequest,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = FeedbackApiFetchParamCreator(
        configuration
      ).feedback(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * ***Do not abuse this endpoint.***  This returns a token usable for submitting feedback. You should request a token, ***if (and only if) a user is on a feedback page***  As a rudimentary way of rate-limiting feedback, this endpoint returns a token. To post feedback, you will need this token.  Tokens gain validity after 10s, and are invalid after 12h of being issued. They are not refreshable, and are only valid for one usage.  Global Rate-Limiting:  - hourly: 20 tokens per hour  - daily: 50 tokens per
     * @summary Get a feedback-token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getToken(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<TokenResponse> {
      const localVarFetchArgs =
        FeedbackApiFetchParamCreator(configuration).getToken(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * FeedbackApi - factory interface
 * @export
 */
export const FeedbackApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * ***Do not abuse this endpoint.***  This posts the actual feedback to github and returns the github link. For this Endpoint to work, you need to generate a token via the `/api/feedback/get_token` endpoint.  ***Important Note:*** Tokens are only used if we return a 201 Created response. Otherwise, they are still valid
     * @summary Post feedback
     * @param {TokenRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedback(body?: TokenRequest, options?: any) {
      return FeedbackApiFp(configuration).feedback(body, options)(
        fetch,
        basePath
      );
    },
    /**
     * ***Do not abuse this endpoint.***  This returns a token usable for submitting feedback. You should request a token, ***if (and only if) a user is on a feedback page***  As a rudimentary way of rate-limiting feedback, this endpoint returns a token. To post feedback, you will need this token.  Tokens gain validity after 10s, and are invalid after 12h of being issued. They are not refreshable, and are only valid for one usage.  Global Rate-Limiting:  - hourly: 20 tokens per hour  - daily: 50 tokens per
     * @summary Get a feedback-token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getToken(options?: any) {
      return FeedbackApiFp(configuration).getToken(options)(fetch, basePath);
    },
  };
};

/**
 * FeedbackApi - object-oriented interface
 * @export
 * @class FeedbackApi
 * @extends {BaseAPI}
 */
export class FeedbackApi extends BaseAPI {
  /**
   * ***Do not abuse this endpoint.***  This posts the actual feedback to github and returns the github link. For this Endpoint to work, you need to generate a token via the `/api/feedback/get_token` endpoint.  ***Important Note:*** Tokens are only used if we return a 201 Created response. Otherwise, they are still valid
   * @summary Post feedback
   * @param {TokenRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedbackApi
   */
  public feedback(body?: TokenRequest, options?: any) {
    return FeedbackApiFp(this.configuration).feedback(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * ***Do not abuse this endpoint.***  This returns a token usable for submitting feedback. You should request a token, ***if (and only if) a user is on a feedback page***  As a rudimentary way of rate-limiting feedback, this endpoint returns a token. To post feedback, you will need this token.  Tokens gain validity after 10s, and are invalid after 12h of being issued. They are not refreshable, and are only valid for one usage.  Global Rate-Limiting:  - hourly: 20 tokens per hour  - daily: 50 tokens per
   * @summary Get a feedback-token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedbackApi
   */
  public getToken(options?: any) {
    return FeedbackApiFp(this.configuration).getToken(options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * HealthApi - fetch parameter creator
 * @export
 */
export const HealthApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * If this endpoint does not return 200, the API is experiencing a catastrophic outage. Should never happen.
     * @summary API healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiHealth(options: any = {}): FetchArgs {
      const localVarPath = `/api/health`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * If this endpoint does not return 200, the CDN is experiencing a catastrophic outage. Should never happen.
     * @summary CDN healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cdnHealth(options: any = {}): FetchArgs {
      const localVarPath = `/cdn/health`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * If this endpoint does not return 200, the Website is experiencing a catastrophic outage. Should never happen.
     * @summary Website healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webHealth(options: any = {}): FetchArgs {
      const localVarPath = `/health`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  return {
    /**
     * If this endpoint does not return 200, the API is experiencing a catastrophic outage. Should never happen.
     * @summary API healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiHealth(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs =
        HealthApiFetchParamCreator(configuration).apiHealth(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * If this endpoint does not return 200, the CDN is experiencing a catastrophic outage. Should never happen.
     * @summary CDN healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cdnHealth(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs =
        HealthApiFetchParamCreator(configuration).cdnHealth(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * If this endpoint does not return 200, the Website is experiencing a catastrophic outage. Should never happen.
     * @summary Website healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webHealth(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs =
        HealthApiFetchParamCreator(configuration).webHealth(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * If this endpoint does not return 200, the API is experiencing a catastrophic outage. Should never happen.
     * @summary API healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiHealth(options?: any) {
      return HealthApiFp(configuration).apiHealth(options)(fetch, basePath);
    },
    /**
     * If this endpoint does not return 200, the CDN is experiencing a catastrophic outage. Should never happen.
     * @summary CDN healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cdnHealth(options?: any) {
      return HealthApiFp(configuration).cdnHealth(options)(fetch, basePath);
    },
    /**
     * If this endpoint does not return 200, the Website is experiencing a catastrophic outage. Should never happen.
     * @summary Website healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webHealth(options?: any) {
      return HealthApiFp(configuration).webHealth(options)(fetch, basePath);
    },
  };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
  /**
   * If this endpoint does not return 200, the API is experiencing a catastrophic outage. Should never happen.
   * @summary API healthcheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public apiHealth(options?: any) {
    return HealthApiFp(this.configuration).apiHealth(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * If this endpoint does not return 200, the CDN is experiencing a catastrophic outage. Should never happen.
   * @summary CDN healthcheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public cdnHealth(options?: any) {
    return HealthApiFp(this.configuration).cdnHealth(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * If this endpoint does not return 200, the Website is experiencing a catastrophic outage. Should never happen.
   * @summary Website healthcheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public webHealth(options?: any) {
    return HealthApiFp(this.configuration).webHealth(options)(
      this.fetch,
      this.basePath
    );
  }
}
